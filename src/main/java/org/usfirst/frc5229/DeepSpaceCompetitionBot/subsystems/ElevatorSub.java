// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5229.DeepSpaceCompetitionBot.subsystems;


import org.usfirst.frc5229.DeepSpaceCompetitionBot.Robot;
import org.usfirst.frc5229.DeepSpaceCompetitionBot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMax.IdleMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMax; 
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class ElevatorSub extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax sparkMax1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private int timeoutMs = 10;
	private int pidIdx = 0;
	private int peakCurrent = 39;
	private int peakCurrentDur = 0;
    private int contCurrent = 37;
    private boolean raise = false;
    private boolean lower = false;
    public double pos;
    public int maxVelocity = 0;
    private CANPIDController sparkPIDCont;
    private CANEncoder s_encoder;
    private boolean limit = false;
    private boolean reset = false;
    private boolean top;
    private boolean bottom;

    

    public ElevatorSub() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        sparkMax1 = new CANSparkMax(2, MotorType.kBrushless);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    
    sparkPIDCont = sparkMax1.getPIDController();
    s_encoder = sparkMax1.getEncoder();

    sparkMax1.setIdleMode(IdleMode.kBrake);
    sparkMax1.setSmartCurrentLimit(39);
    sparkPIDCont.setFF(0.001);
    sparkPIDCont.setP(0.5);
    sparkPIDCont.setI(0.03);
    sparkPIDCont.setD(10);
    sparkPIDCont.setIZone(30);
    
    
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    public void RunElevator(double speed, boolean noLimit) { 
        
        pos = s_encoder.getPosition();

        System.out.println(pos);
        
        if (pos <= -166.75 && speed < -0.01 && noLimit == false) { //pos <=-300
            sparkMax1.set(0);
            top = true;
            bottom = false;
        }
        else if (pos >= -1.35 && speed > 0.01 && noLimit == false) { //pos >= 68420
            sparkMax1.set(0); //68420
            top = false;
            bottom = true;
        }
        else if (noLimit == true) {
            sparkMax1.set(speed);
            reset = true;
            //sparkPIDCont.setReference(speed*1000, ControlType.kVelocity);
        }
        else if (speed > .01 || speed < -.01) {
            sparkMax1.set(speed);
            top = false;
            bottom = false;
        }
        else {
            sparkMax1.set(-0.025);
        }
        if (reset == true) {
            s_encoder.setPosition(-1.35);
        }
        reset = false;
        limit = false;
        //else {
        //    sparkMax1.set(ControlMode.Position, sparkMax1.getSelectedSensorPosition());
        //}
        SmartDashboard.putBoolean("ElevatorTop", top);
        SmartDashboard.putBoolean("ElevatorBottom", bottom);
    }
    public void PIDElevator(int option) {
       pos = s_encoder.getPosition(); 
       
       if (option == 1 && (pos > -20 || pos < -23)) { //raise elevator low hatch
            sparkPIDCont.setReference(-21.8, ControlType.kPosition);
        }
        else if (option == 2 && (pos > -85 || pos < -87)) { //raise elevator mid hatch
            sparkPIDCont.setReference(-86, ControlType.kPosition);
        }
        else if (option == 3 && (pos > -141 || pos < -143)) { //raise elevator high hatch
            sparkPIDCont.setReference(-142, ControlType.kPosition);
        }
        else if (option == 4 && (pos > -58 || pos < -60)) { //raise elevator low ball
            sparkPIDCont.setReference(-59, ControlType.kPosition);
        }
        else if (option == 5 && (pos > -118 || pos < -120)) { //raise elevator mid ball
            sparkPIDCont.setReference(-119, ControlType.kPosition);
        }
        else if (option == 6 && (pos > 501 || pos < 499)) { //raise elevator high ball
            sparkPIDCont.setReference(500, ControlType.kPosition);
        }
        else if (option == 7 && limit == false) { //lower elevator hatch slightly
            sparkPIDCont.setReference(pos + 7, ControlType.kPosition);
            limit = true;
        }
        else if (option == 8) { //lower elevator all
            sparkPIDCont.setReference(1, ControlType.kPosition);
        }
        else if (option == 9 && (pos > -13 || pos < -15)) { //raise elevator hatch recival
            sparkPIDCont.setReference(-14.7, ControlType.kPosition);
        }
        else if (option == 10) { //raise elevator ball recival
            sparkPIDCont.setReference(500, ControlType.kPosition);
        }
        else {
            sparkMax1.set(-0.025);
        }
    }
    @Override
    public void periodic() {
        // Put code here to be run every loop
        //pos = sparkMax1.getSelectedSensorPosition();

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

